---
{"dg-publish":true,"permalink":"/计算机科学/操作系统/02. 操作系统-进程/","tags":["Operating-Systems"]}
---


# 程序、进程、线程

+ 程序
  + 程序是一段静态的代码
  + 程序不能作为资源分配的基本单位（程序占资源较多，有很多个基本单元组成）
  + 程序创建进程
  + 程序不能并发

+ 进程

  + 正在运行的一段程序。
  + **资源分配的基本单位**
  + 进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。

  ![img](https://i.loli.net/2021/03/07/td5WL1qsJjvuKfR.png)

+ 线程
  + **独立调度的基本单位**
  + **一个进程中可以有多个线程，它们共享进程资源**
  + QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。



**进程和线程的区别**：

+ 身份：进程是资源分配的基本单位，线程是CPU调度的基本单位

+ 资源：进程在执行过程中拥有独立的内存单元，进程间不会相互影响；而多个线程共享进程的内存，线程间会相互影响（一个线程意外终止会导致同一个进程的其他线程也终止）
+ 并发：进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量，但缺点是进程在同一时间只能干一件事（进程在执行的过程中如果阻塞，整个进程就会挂起）；线程是为了实现进程内部的并发，由于其较小的开销、便捷的通信，能减少程序在并发执行时所付出的时空开销。
+ 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，**创建或撤销进程所付出的开销远大于创建或撤销线程时的开销**。
+ 通信：线程间可以通过直接读写同一进程中的数据进行通信（通信简单），但是进程通信需要借助 IPC（通信复杂，需要经过内核）。



# 进程状态

![img](https://i.loli.net/2021/03/07/QfCc5wkI8SzGRad.png)

进程（线程）有三种状态（区别于任务，既然已经有进程了，那么就不会处于睡眠态）：

- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 睡眠状态（waiting）：缺少需要的资源从而由运行状态转换而来，资源不包括CPU时间片。

**只有就绪态和运行态可以相互转换，其它的都是单向转换**，就绪状态的进程通过**调度算法**转为运行态，运行态的进程在CPU时间片用完后转为就绪态。





#  进程和虚拟化间的关系

CPU虚拟化是只指创造多个CPU的假象，方法是通过进程时间片实现的（时分复用）。时分复用则涉及到了如何合理管理进程调度的问题。



# 操作系统创建进程时的工作

+ 加载的代码和静态数据到内存中；
+ 创建和初始化栈（程序使用栈存放局部变量、函数参数等）
+ 创建和初始化堆（动态分配malloc）
+ IO设置工作
+ 进入程序入口(main)将CPU控制权交给进程。



# 进程API

## fork()

我们可以在一个含main函数的main.cpp里调用`rc=fock()`创建子进程（父进程就是main.cpp本身），调用以后，系统中存在这两个进程，并且他们的`rc`不同（rc=0表示子进程，rc=1表示父进程），这两个进程都会继续执行`rc=fock()`之后的程序，就好像系统里有两个完全一样的main进行一样。

至于这两个程序谁运行的快，则取决于系统的进程调度算法。



## wait()

如果想要让父进程等待子进程结束后，再运行，可以在`rc=1`条件中执行系统调用`wait()`，这样只有子进程结束后父进程才会运行。



## exec()

在fock()之后，创建了自身的一个拷贝，然后可以利用`exec()`来把自身替换成新的程序。这个替换仍然保留进程号，但是进程的数据都会被重置。

```
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>

char command[256];
void main()
{
  int rtn; /*子进程的返回数值*/
  while(1) {
      /* 从终端读取要执行的命令 */
      printf( ">" );
      fgets( command, 256, stdin );
      command[strlen(command)-1] = 0;
      if ( fork() == 0 ) {/* 子进程执行此命令 */
         execlp( command, NULL );
         /* 如果exec函数返回，表明没有正常执行命令，打印错误信息*/
         perror( command );
         exit( errno );
      }
      else {/* 父进程， 等待子进程结束，并打印子进程的返回值 */
         wait ( &rtn );
         printf( " child process return %d\n", rtn );
      }
  }
}
```





# 进程调度算法

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

+ **先来先服务 first-come first-serverd（FCFS）**

  非抢占式的调度算法，按照请求的顺序进行调度。

  有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

+ **短作业优先 shortest job first（SJF）**

  非抢占式（再运行一个进程时，即使有更短的作业到来，也不会相应）的调度算法，按估计运行时间最短的顺序进行调度。

  长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

+ **最短剩余时间优先 shortest remaining time next（SRTN）**

  最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。?没有解决长作业等待问题阿

+ **时间片轮转**

  将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，队首进程去往就绪队列的末尾。

  时间片轮转算法的效率和时间片的大小有很大关系：

  - 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
  - 而如果时间片过长，那么实时性就不能得到保证。

+ **优先级调度**

  为每个进程分配一个优先级，按优先级进行调度。

  为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

+ **多级反馈队列**

  一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

  ![img](https://i.loli.net/2021/03/07/7qtlzj5iXRgA2hN.png)

  多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列。当进程在第一个时间片内没有执行完毕，则进入第二队列，该队列时间片是原来的两倍；同理，第三队列时间是4，第四队列是8，那么这个原来需要交换100次的进程现在只要交换7次。

  需要注意，**每个队列优先权也不同，最上面的优先权最高**。也就说，只有上一个队列没有进程在排队，才能调度当前队列上的进程。

  
