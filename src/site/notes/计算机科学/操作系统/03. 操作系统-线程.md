---
{"dg-publish":true,"permalink":"/计算机科学/操作系统/03. 操作系统-线程/","tags":["Operating-Systems"]}
---

进程只有一个执行点（程序计数器），而线程有多个执行点（程序计数器），单个线程和进程类似，只有一点区别：线程共享内存，进程内存独立。

进程有一个进程控制块记录信息，多线程则有多个线程控制块TCB；多线程也有多个栈，用于每个线程的函数调用和变量存储。



# 线程创建

线程自创建时便开始执行，`join()`是等待线程运行结束才继续执行主线程。线程创建时还可以传入参数，线程返回时可以获取返回值。

```
bool running = true;
func()
{
	while(running);
}

int main()
{
    thread threads[4];
    for (int i = 0; i < 4; i++)
    {
    threads[i] = thread(func);
    }
    ...
    running = false;
    for (auto &thread : threads)
    {
    thread.join();
    }
    return;
}

```



# 临界区和原子性

修改一个全局变量的值，一般的步骤是从内存中取出变量值，对变量值进行运算，最后再写回内存中。倘若有两个线程都想要修改同一个全局变量，便会产生一定的问题：当一个线程在执行完第二个步骤时，时间片结束，操作系统会把该线程数据保存到TCB中，如果此时另一个线程恰好被选中运行，并顺利地修改完变量写入到内存；等到第一个线程再次恢复，第二个线程的变量结果会被覆盖。

**临界区**：多线程中，访问共享资源的代码区域；

**竞态条件**：多个线程几乎同时进入临界区，都试图修改共享数据，导致不确定结果；

**同步原语**：由硬件提供的进行同步的指令。如锁、信号量等 

**原子方式**：指临界区“作为一个单元”，要么全部执行，要么都就不执行，中间不能被打断；在多线程中，必须借助**同步原语**为临界区支持原子性。



# 等待线程（睡眠/唤醒交互机制）

除了共享资源，多线程另一个重要的问题是：如何实现一个线程在继续之前必须等待另一个线程完成某些操作的交互支持。



# 线程同步方式

## 锁

先谈一谈互斥锁。

作用：用来实现线程的同步和通信。

只有一个线程可以持有锁，未持有锁的线程要等待，直到获取锁以后才能执行后续代码。

### API

```
pthread_mutex_t lock; 
pthread_mutex_init(&lock);//初始化锁
void func()
{
	int rc = pthread_mutex_lock(&lock); //加锁
	assert(rc==0); // 加锁和释放时要检查加锁是否成功，否则多个线程可能进入临界区
	x+=1;
	rc = pthread_mutex_unlock(&lock); //解锁
	assert(rc==0);
}

int main()
{
	threads.join();
	pthread_mutex_destroy(&lock);//销毁锁
	...
}
```

需要被加锁的所有线程只需使用相同的锁即可，并不一定都要在同一块代码中访问临界区，如下。一个进程中一个时间片只能运行一个线程，如果n个线程都与锁mutex1绑定，那么其中一个线程持有该锁时，等待它的时间片结束，锁并不会归还，系统运行其他(n-1)个线程，由于这些线程未持有锁，执行到被mutex1加锁的临界区时会进入休眠态。

```
pthread_mutex_t lock; 
pthread_mutex_init(&lock);//初始化锁
void func1()
{
	int rc = pthread_mutex_lock(&lock); //加锁
	assert(rc==0); 
	x+=1;
	rc = pthread_mutex_unlock(&lock); //解锁
	assert(rc==0);
}

void func2()
{
	int rc = pthread_mutex_lock(&lock); //加锁
	assert(rc==0); 
	x+=1;
	rc = pthread_mutex_unlock(&lock); //解锁
	assert(rc==0);
}

int main()
{
	threads[0] = Pthread_create(&thread,NULL, func1, NULL);
	threads[1] = Pthread_create(&thread,NULL, func2, NULL);
	threads.join();
	pthread_mutex_destroy(&lock);//销毁锁
	...
}
```





### 其他类型的锁

+ **读写锁**：分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁，其它获取写锁失败的线程都会进入睡眠状态。非常适合适用于读取数据的频率远远大于写数据的频率的场合
+ **自旋锁**：在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，但同时由于会得到时间片，因此也会占用系统时间，自旋锁在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。





## 条件变量



### API

休眠代码，

```
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZE; 
pthread_cond_t cond = PTHREAD_COND_INITIALIZE; //初始化条件
Pthread_mutex_lock(&lock);	// 加锁
while(ready==0)	//判断条件是否满足
	Pthread_cond_wait(&cond, &lock); //等待
Pthread_mutex_unlock(&lock);	// 解锁
```

其他线程的唤醒代码，

```
Pthread_mutex_lock(&lock);	// 加锁
ready=1;//条件置1
Pthread_cond_signal(&cond); //发出信号
Pthread_mutex_unlock(&lock);	// 解锁
```

使用pthread_cond_signal不会有“惊群现象”产生，他最多只给一个线程发信号。假如有多个线程正在阻塞等待着这个条件变量的话，那么是根据各等待线程优先级的高低确定哪个线程接收到信号开始继续执行。





### 实现join()

很多情况下，我们需要一个线程去等待另外一个线程完成某个操作，比如线程库中的`join()`就是主线程等待子线程执行完毕后才从休眠中被唤醒。

如何实现这种等待？

使用共享变量是一个办法，但是效率低下，因为主线程需要自旋检查，占用CPU时间，如下：

```
int done = 0;
void* func()
{
	...
	done=1;
	return;
}
int main()
{
    Pthread_create(&thread, NULL, func, NULL);
    while(done); //自旋检查
    return 0;
}

```



线程库提供了条件变量来实现这种等待。条件变量有两种操作：

+ wait()：线程要睡眠时调用wait()；
+ signal()：当线程想要唤醒再某个条件变量上的睡眠线程时，调用signal()

一个优秀的join()实现方法如下，

```
int done = 0;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZE; 
pthread_cond_t cond = PTHREAD_COND_INITIALIZE;

void thread_exit()
{
	Pthread_mutex_lock(&lock);
	done = 1;
	Pthread_cond_signal(&cond);
	Pthread_mutex_unlock(&lock);
}

void *thread_func()
{
	printf("child thread!");
	thread_exit();//子线程执行结束，准备唤醒主线程
	return NULL;
}

voif thread_join()
{
    Pthread_mutex_lock(&lock);	
    while(done==0)	
        Pthread_cond_wait(&cond, &lock); 
    Pthread_mutex_unlock(&lock);
}

int main()
{
	printf("parent begin!");
	pthread_t p;
	Pthread_create(&p, NULL, thread_func, NULL);
	thread_join();//等待子线程结束
	printf("parent end!");
	return;
}

```

`Pthread_cond_wait`需要两个参数，一个是条件，这个条件只有与`Pthread_cond_signal`的条件相同，才会被相应唤醒；第二个是互斥锁，`wait()`的职责是释放锁，并且让调用线程休眠，当线程被唤醒时，通过`wait()`重新取得锁。

这段程序运行有两种情况，在主线程创建出子线程后：

+ 主线程继续占用CPU控制权，执行`thread_join()`，由于此时`done=0`，因此主线程调用`wait()`并进入睡眠（`Pthread_mutex_unlock`未运行）；然后子线程开始运行，执行`thread_exit()`，并唤醒主进程；主进程从`wait()`调用返回并持有互斥锁，通过`Pthread_mutex_unlock`释放锁。
+ 子线程先取得CPU控制权，执行`thread_exit()`，但是`Pthread_cond_signal`没有可以被唤醒的线程，于是子线程结束；主线程运行后，因为状态变量`done=1`，所以不调用`wait()`，而是直接通过`Pthread_mutex_unlock`释放锁。

从上面分析可以看出，状态变量`done`是不可缺少的，否则第二种情况主线程会执行`wait()`，并将没有线程可以唤醒它。

其次，加锁是必要的。第一种情况下，主线程检查完`done==0`后如果被打断，子线程开始运行并执行结束，然后主线程恢复后会调用`wait()`导致没有线程可以唤醒它。

其次，如果创建的子线程有n个，则需要执行n次`thread_join()`来等待所有线程结束，并且`done`也应该用n来判断。



### 生产者和消费者

该问题也称有届缓存区。例如在读取相机图片的时候，假设从相机读取一张图片的时间需要10ms，而处理一张图像的时间也是10ms，那么利用一个线程先读取再处理总共需要花费20ms。

而如果一个线程负责读取，另一个线程负责处理，则可能的时间花费只有10多ms。这也是并发带来的好处。

考虑下面的生产者和消费者实现版本，显然生产线程和消费线程之间存在临界区(count)，但是

为什么只用锁不行?

```
int buffer[MAX];
int fill_ptr = 0;
int use_ptr = 0;
int count = 0;

void put(int value)
{
	buffer[fill_ptr]=value;
	fill_ptr = (fill_ptr+1)%MAX;//循环缓存区，从头部开始写
	count++;
}

int get()
{
	int tmp = buffer[use_ptr];
	use_ptr = (use_ptr+1)%MAX;
	count--;
	return tmp;
}

void *producer(void *arg)
{
	int loops = (int)arg;
	for(int i= 0;i<loops;i++)
	{
		if (count < MAX) 
			put(i);
	}
}

void *consumer(void *arg)
{
	while(1){
		if (count > 0) {
			int tmp = get();
			printf("%d\n", tmp);
		}
	}
}
```

既然锁无法使用，我们可以考虑使用条件变量，如下版本。但是这个版本也存在问题：多消费线程和多生产者线程情况下产生多度消费或过度生产的问题。比如一个生产者线程和两个消费者线程的情况，当第一个消费者线程调用`wait()`进入休眠后，生产者线程运行并生产了一个数据，并唤醒第一个消费者线程；然后第二个消费者线程先取得锁而运行，由于`count=1`，该线程会消费掉最后一个数据，接着第一个消费者获得锁，也试图消费数据，然而实际上现在已经没有数据了。

```
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZE; 
pthread_cond_t cond = PTHREAD_COND_INITIALIZE; //初始化条件


void *producer(void *arg)
{
	int loops = (int)arg;
	for(int i= 0;i<loops;i++)
	{
		Pthread_mutex_lock(&lock);
		if (count == MAX){
			Pthread_mutex_wait(&cond, &lock);
		}
		put(i);
		Pthread_mutex_signal(&cond);
		Pthread_mutex_unlock(&lock);
	}
}

void *consumer(void *arg)
{
	while(1){
		Pthread_mutex_lock(&lock);
		if (count == 0){
			Pthread_mutex_wait(&cond, &lock);
		}
		get();
		Pthread_mutex_signal(&cond);
		printf("%d\n", tmp);
	}
}
```

这个问题主要是因为采用`if`判断导致的，回顾前文的条件变量实例，你会发现都是用的`while`，因此在条件变量中，应总是选择`while`而不是`if`。以下是改进的版本，

```
void *producer(void *arg)
{
	int loops = (int)arg;
	for(int i= 0;i<loops;i++)
	{
		Pthread_mutex_lock(&lock);
		while (count == MAX){
			Pthread_mutex_wait(&cond, &lock);
		}
		put(i);
		Pthread_mutex_signal(&cond);
		Pthread_mutex_unlock(&lock);
	}
}

void *consumer(void *arg)
{
	while(1){
		Pthread_mutex_lock(&lock);
		while (count == 0){
			Pthread_mutex_wait(&cond, &lock);
		}
		get();
		Pthread_mutex_signal(&cond);
		printf("%d\n", tmp);
	}
}
```

但是问题并没有完全解决，仍然存在一个由于使用单一条件变量产生的隐患：当MAX=1，起初`count=0`，两个消费者线程都进入休眠状态；此时生产者获得CPU控制权，并且生产了数据，从而也进入了休眠态，并且换醒了某个消费者线程，该消费者线程消费数据并发送唤醒信号，但此时可能唤醒生产者线程，也可能唤醒另一个消费者线程，如果很不幸地唤醒了另一个消费者线程，那么由于`count=0`，这个消费者线程又会休眠，至此，所有线程都处于休眠状态。

事实上，消费者不应当唤醒消费者，生产者也不应当唤醒生产者；也就是消费者和生产者应该使用不同的条件变量，以下是最终版本，

```
int buffer[MAX];
int fill_ptr = 0;
int use_ptr = 0;
int count = 0;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZE; 
pthread_cond_t empty = PTHREAD_COND_INITIALIZE; 
pthread_cond_t fill = PTHREAD_COND_INITIALIZE; 

void put(int value)
{
	buffer[fill_ptr]=value;
	fill_ptr = (fill_ptr+1)%MAX;//循环缓存区，从头部开始写
	count++;
}

int get()
{
	int tmp = buffer[use_ptr];
	use_ptr = (use_ptr+1)%MAX;
	count--;
	return tmp;
}

void *producer(void *arg)
{
	int loops = (int)arg;
	for(int i= 0;i<loops;i++)
	{
		Pthread_mutex_lock(&lock);
		while (count == MAX){
			Pthread_mutex_wait(&empty, &lock);
		}
		put(i);
		Pthread_mutex_signal(&fill);
		Pthread_mutex_unlock(&lock);
	}
}

void *consumer(void *arg)
{
	while(1){
		Pthread_mutex_lock(&lock);
		while (count == 0){
			Pthread_mutex_wait(&fill, &lock);
		}
		get();
		Pthread_mutex_signal(&empty);
		printf("%d\n", tmp);
	}
}
```



## 信号量

### API

信号量是有一个整数值的对象，通过初值不同的设定可以将信号量当作锁或者变量条件来使用（可以看成封装好的既可以实现锁也可以实现条件变量的函数）。信号量的初始化如下，

```
sem_t s;
sem_init(&s, 0, 1);// 第二参数为0表示信号量被同一进程多个线程共享
					// 第三参数设定信号量初值为1
```

可以有两个函数来操作它，

+ `sem_wait()`：如果调用该函数时信号量值小于等于0，则导致调用线程等待；否则递减信号量并立即返回。
+ `sem_post()`：调用该函数会递增信号量的值，如果有等待线程，则唤醒其中一个。

由于信号量使用简单，很多程序员都只用信号量，不用锁和条件变量。



### 实现信号量

我们可以用锁和条件变量实现信号量的两个函数，

```
typedef struct sem_t{
	int value;
	pthread_cond_t cond;
	pthread_mutex_t lock;
}sem_t;

void sem_wait(sem_t *s)
{
	Mutex_lock(&s->lock);
	while(s->value <= 0)
		Cond_wait(&s->cond, &s->lock);
	s->value--;
	Mutex_unlock(&s->lock);
}

void sem_post(sem_t *s)
{
	Mutex_lock(&s->lock);
	s->value++;
	Cond_signal(&s->cond);
	Mutex_unlock(&s->lock);
}
```

我们将在下面的信号量应用分析这样实现的合理性。



### 信号量实现互斥锁

当信号量的初值为1时，可以实现互斥锁效果，

```
sem_wait(&s);
...//临界区
sem_post(&s);
```

假设有两个线程A、B，A先运行调用`sem_wait()`，在其内部取得锁，保证线程B不会抢断，线程A将`value`递减到0，并释放锁。所有线程A进入临界区，假如线程B还没有尝试获取过锁，那么线程A会调用`sem_post()`，在其内部，A取得锁，将信号量重置为1，因为此时没有休眠线程，因此不会唤醒线程，于是A释放锁返回，执行结束。接下来线程B也会重复一遍上述过程。

在`sem_wait`调用返回后，线程A会失去锁，如果线程B此时也调用`sem_wait()`并立即取得锁，由于信号量现在等于0，则会执行条件等待，进入休眠，**`wait()`确保线程B休眠时交出锁的使用权，并在之后线程B被唤醒时归还**。所以现在，只有线程A运行在临界区，当A调用`sem_post()`时，A取得锁，并重置信号量值，唤醒线程B；线程B重新取得锁后，判断信号量值为1，故跳出`while`，递减value，执行于A类似的后续操作。



### 信号量实现条件变量

#### 实现join()

当初始值等于0时，可以实现join()

```
sem_t s;
void *child(){
	...
	sem_post(&s);
	return NULL;
}

int main()
{
	sem_init(&s, 0, 0);
	Pthread_create(&thread, NULL, child, NULL);
    sem_wait(&s);
    ...
}
```

如果创建线程后，主线程先取得锁，则由于信号量为0，主线程休眠，并暂时交出锁的使用权。然后子线程进入child函数，执行完所有操作后，调用`sem_post()`取得锁，递增信号量为1，唤醒主线程，然后线程结束；主线程被唤醒后，重新取得锁，递减信号量为0，并释放锁。

如果创建线程后，子线程先调用`sem_post`取得锁，递增信号量为1（没有需要被唤醒的进程），然后释放锁，线程结束；主线程调用`sem_wait`，由于信号量为1，不进入等待，直接递减信号量为0，主线程结束。

当创建了N个子线程时，主线程也需要N个`sem_wait`用于等待每个线程，就如同`join()`一样。



#### 生产者和消费者

首先，看第一版实现，

```
sem_t empty, full;
sem_init(&empty, 0, MAX);
sem_init(&full, 0, 0);
void *producer(void *arg)
{
	int loops = (int)arg;
	for(int i= 0;i<loops;i++)
	{
		sem_wait(&empty);
		put(i);
		sem_post(&full);
	}
}

void *consumer(void *arg)
{
	while(1){
		sem_wait(&full);
		get(i);
		sem_post(&empty);
	}
}
```

我们注意到，信号量的值可以代表生产和消费的数量，这样我们就不用像使用条件变量一样建立状态变量了。其次由于一开始没有数据， empty的初值应当设置为MAX，full的初值设置为0。

但上述实现在多个生产线程和消费线程，并且MAX>1时会存在竞态条件：当生产线程A调用`sem_wait()`后，`empty`的值变为MAX-1，然后A执行`put()`，此时A已经释放了锁，生产线程调用`sem_wait`取得了锁，也进入了`put()`，即多个生产线程在临界区，会造成数据覆盖。

产生上述原因的根源便在于`sem_wait()`返回后，线程将不再持有锁！因此这里还需要加上一层互斥锁（可以用信号量实现），如下，

```
sem_t mutex;
sem_init(&full, 0, 1);

void *producer(void *arg)
{
	int loops = (int)arg;
	for(int i= 0;i<loops;i++)
	{
		sem_wait(&mutex);
		sem_wait(&empty);
		put(i);
		sem_post(&full);
		sem_post(&mutex);
	}
}

void *consumer(void *arg)
{
	while(1){
		sem_wait(&mutex);
		sem_wait(&full);
		get(i);
		sem_post(&empty);
		sem_post(&mutex);
	}
}
```

然而，这个版本又引发了另外一个重要问题——**死锁**。

**当线程A持有锁LA，正在等待获取另外一个锁LB；而线程B持有锁LB，却在等待获取锁L1**的时候，死锁就产生了。

在上面的代码中，假设只有一个生产线程和一个消费线程，消费者先执行了`sem_wait(&mutex)`获得了`mutex`锁，然后正要调用`sem_wait(&full)`时，该线程时间片结束但仍保留`mutex`锁的所有权，生产者线程调用`sem_wait(&mutex)`，因为未持有`mutex`锁而进入等待；接着消费者线程进入`sem_wait(&full)`，因为一开始没有数据，因此释放了`full`锁而进入等待。至此，两个线程都进入了等待——生产者等待消费者释放`mutex`，消费者等待生产者释放`full`。

解决办法是减少`mutex`的作用域，如下最终可行版本：

```
sem_t mutex;
sem_init(&full, 0, 1);

void *producer(void *arg)
{
	int loops = (int)arg;
	for(int i= 0;i<loops;i++)
	{
		sem_wait(&empty);
		sem_wait(&mutex);
		put(i);
		sem_post(&mutex);
		sem_post(&full);
		
	}
}

void *consumer(void *arg)
{
	while(1){
		sem_wait(&full);
		sem_wait(&mutex);
		get(i);
		sem_post(&mutex);
		sem_post(&empty);
	}
}
```





#### 哲学家进餐问题

该问题是有Dijkstra提出的，讨论的是多线程下竞争下的同步问题。

![img](https://i.loli.net/2021/03/08/dgAfUvJRBaF2spt.jpg)

每个哲学家作为一个线程，其基本循环为,

```
while(1){
	think();
	getforks();
	eat();
	putforks();
}
```

我们假设哲学家都知道自己的编号p，那么哲学家p两边叉子的编号可以通过下面函数获取

```
int left(int p){return p;}
int right(int p){return (p+4)%5;}
```

将每个叉子状态作为信号量，都用1初始化，拿起时值变为0；五个信号量用forks数组存储。

如果规定所有的哲学家都先拿起自己左手边的叉子，再拿起右手边的叉子，拿叉子和放叉子的代码如下，

```
void getforks()
{
	sem_wait(forks[left(p)])；
	sem_wait(forks[right(p)])；
}

void putforks()
{
	sem_post(forks[left(p)])；
	sem_post(forks[right(p)])；
}
```

这样的方案存在问题！假设当哲学家都拿到了左手叉子的时候，他们每个人都会在`sem_wait(forks[right(p)])`中陷入等待，结果导致所有哲学家饿死！

解决上述最简单的方法就是改变某个或某些哲学家的取餐顺序，比如让4号哲学家改用先取右手叉。

```
void getforks()
{
	if (p == 4){
		sem_wait(forks[right(p)])；
		sem_wait(forks[left(p)])；
	}else{
		sem_wait(forks[right(p)])；
		sem_wait(forks[left(p)])；	
	}
	
}

void putforks()
{
	sem_post(forks[left(p)])；
	sem_post(forks[right(p)])；
}
```





## 并发缺陷总结

常见的并发缺陷分为：非死锁缺陷、死锁缺陷。

非死锁缺陷包括：

+ 违反原子性缺陷：对于临界区代码理解不到位，认为临界区代码的执行是符合原子性的。比如`count++`，认为一个线程一定可以不间断地一次执行完它，却忽视了它实际包括内存读取、运算、内存写入三个步骤。（多个写）

  该缺陷可以通过加互斥锁解决。

+ 违反顺序缺陷：预期认为或只考虑线程A先于线程B执行，但实际上可能执行顺序相反。如如在A线程中创建对象，在B线程中使用对象。（一个写一个读）

  该缺陷可以通过加条件变量来实现线程等待。



死锁缺陷，产生的条件如下

+ 互斥：多个线程对于需要的资源进行互斥的访问（比如前文生产者和消费者竞争一个mutex锁）
+ 非抢占：线程在竞争到资源后，不能被抢占（如消费者获得mutex锁后除非主动unlock否则不能被生产者抢走）
+ 持有并等待：线程在竞争中持有了资源，同时有在等待其他资源。（比如前文消费者获得mutex锁后，等待生产者生产数据）
+ 环路等待：线程之间存在一个环路，环路上每个线程都负责控制一个资源，但这个资源又是下一个线程所要申请的。（如生产者控制着数据（full）资源，申请mutex资源，而消费者控制mutex，申请数据(full)资源）



# 线程通信方式

临界区、互斥量（与锁有关）、信号量、事件（与条件变量有关）

- **线程同步：控制多个线程按一定顺序执行；**
- **线程通信：线程间传输信息。**

**通信是一种手段**，**同步是目的**，为了达到同步，需要线程之间进行通信，传输一些线程同步所需要的信息。


