---
{"dg-publish":true,"permalink":"/机器人世界/ROS小车项目/07. Joystick摇杆命令发布/"}
---


# 功能规划

+ 实现与树莓派USB接口通信，获取摇杆数据
+ 将遥感数据转换为速度控制，发布话题
+ 运行`driver`功能包订阅速度控制话题，实现麦克纳姆伦地盘的控制


# Driver模块集成

## 配置MACHINE_TYPE

`odom_publisher_node.py` 需要读取系统MACHINE_TYPE变量以决定运动控制算法。
```sh
echo "export MACHINE_TYPE=MentorPi_Mecanum" >> ~/.bashrc
source ~/.bashrc
```

## 配置串口设备

和下位机的通信采用串口设备（ttyACM0，CH340）。

```sh
# 查看已连接的串口设备（找ttyACM0/ttyUSB0等） 
ls /dev/ttyACM* # 若有USB转串口，也可查 ls /dev/ttyUSB*
```

运行`ros_robot_controller/scripts/create_udev_rules.sh`，将rules文件拷贝到树莓派系统中。
`sudo cat /etc/udev/rules.d/99-ttyACM0.rules`查看rules文件内容：

```sh
KERNEL=="ttyACM0", # 只对内核设备名为 `ttyACM0` 的设备生效
SUBSYSTEM=="tty",  # 只对属于 `tty` 子系统的设备生效（tty 子系统是 Linux 管理串口 / 终端的核心）；
SYMLINK+="rrc", # 
GROUP="ubuntu", MODE="0777",
ATTRS{idVendor}=="1a86",  # 匹配 USB 厂商 ID 为 `1a86` 的设备（1a86 是南京沁恒 CH340/CH341 串口芯片的通用 VID）；
ATTRS{idProduct}=="55d4", # 匹配 USB 产品 ID 为 `55d4` 的设备（对应具体的串口硬件型号）
ENV{ID_MM_PORT_IGNORE}="1" #告诉系统的 ModemManager 服务(Linux 默认的调制解调器管理服务)忽略这个端口，避免串口被误识别为调制解调器并占用。
```

在`ros_robot_controller_sdk.py`代码中，使用的串口设备名叫`/dev/rrc`（RRCLite控制板），所以要通过`SYMLINK+="rrc"`进行映射。
```sh
lrwxrwxrwx 1 root root 7 ... /dev/rrc -> ttyACM0
```
为什么不支持用`ttyACM0`，主要有以下原因：
+ 设备名不固定，inux 系统对串口设备的命名（`ttyACM0/ttyACM1/ttyUSB0`）是**按 “插拔顺序 / 识别顺序” 分配**的，而非固定绑定硬件：
+ 语义化，可读性更强。如果你的机器人有多个串口设备（比如：电机控制、激光雷达、蓝牙模块），直接用`ttyACM0/ttyACM1/ttyUSB0` 会完全分不清。

## 命令行自转发布测试

本功能需要用到以下两个节点：

```sh
ros2 run controller odom_publisher
ros2 run ros_robot_controller ros_robot_controller
```

涉及的三个话题：
```sh
# odom_publisher 订阅
controller/cmd_vel geometry_msgs/msg/Twist
cmd_vel geometry_msgs/msg/Twist

# ros_robot_controller 订阅
ros_robot_controller/set_motor MotorsState[]

```

麦克纳姆伦的运动解析写在上位机的`mecanum.py`，即将xyz的线速度和角速度转化为四个电机的转速（这块逻辑应该下沉到RRC上去）。
测试自转。
```sh
ros2 topic pub -r 10 /cmd_vel geometry_msgs/msg/Twist "{linear: {x: 0.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.2}}"
```
