---
{"dg-publish":true,"permalink":"/机器人世界/ROS小车项目/04. ROS1 话题机制Demo/"}
---


案例采用 [# Commit 3672079](https://github.com/KenSporger/ros_21/commit/3672079c2e3db58019ff5f53554039c91680be26)

# 消息类型定义

## common_msgs

在ROS的元功能包`common_msgs`中提供了很多预定义的消息类型，比如std_msgs（标准数据类型）、geometry_msgs（几何学数据类型）、sensor_msgs（传感器数据类型），需要用到的时候只需要包含相应的头文件即可。

```cpp
#include<geometry_msgs/Twist.h>

int main(int argc, char **argv)
{
	// 发布名为/cmd_vel的话题，消息类型为geometry_msgs::Twist（几何旋转），队列长度10
	ros::Publisher mrobot_vel_pub = n.advertise<geometry_msgs::Twist>("/cmd_vel", 10);
	// 创建消息
	geometry_msgs::Twist vel_msg;
	// 线速度和角速度设定
	vel_msg.linear.x = 1.0;
	vel_msg.angular.z = 0.2;
	// 发布消息
	mrobot_vel_pub.publish(vel_msg);
}
```

## 自定义消息

例如案例中的`Person.msg`，定义描述如下：
```c
# Person的成员变量定义
string name
uint8 age
uint8 sex

# 枚举定义
uint8 unknown = 0
uint8 male = 1
uint8 female = 2
```

编译生成后大致为下面的内容。
```cpp
struct Person {
    string name{};
    uint8_t age{0};
    uint8_t sex{0};

    enum {
        unknown = 0u,
        male = 1u,
        female = 2u
    };
};
```

## 标准头

很多ROS消息定义中还会包含一个标准格式的头信息std_msgs/Header。
```cpp
std_msgs/Header header
float64 pitch_rate
float64 yaw_rate
```

其中Header的定义如下，seq是自动设置的消息序列号，stamp是发送时的时间戳，用于时间同步；frame_id是与数据关联的坐标系。
```cpp
uint32 seq
time stamp
string frame_id
```
机器人的核心传感器（激光雷达、相机、IMU、里程计）的消息都内置了 Header，比如：

- `sensor_msgs/LaserScan`（激光雷达数据）：`header.stamp` 标记激光扫描的时间，`header.frame_id` 标记激光雷达安装的坐标系（如`laser_link`）；
- `sensor_msgs/Image`（相机图像）：`header.stamp` 用于和 IMU 数据同步（比如视觉 SLAM 中对齐图像和惯性数据）；
- `sensor_msgs/Imu`（惯性测量单元）：`header.frame_id` 标记 IMU 的安装位置坐标系（如`imu_link`）。

**例子**：在 SLAM（同步定位与建图）中，必须依赖 Header 的`stamp`将激光雷达、IMU 的时序对齐，否则会导致建图漂移；依赖`frame_id`将不同传感器的数据转换到同一坐标系，否则数据融合会出错。

## 消息文件的编译

新增一个`Person.msg`后，要修改`package.xml`和`CMakeLists.txt`。
`package.xml`里要确保有下面两个依赖。
```xml
<build_depend>message_generation</build_depend>
<exec_depend>message_runtime</exec_depend>
```
`CmakeLists.txt`里要包含：
```c
find_package(catkin REQUIRED COMPONENTS
  std_msgs
  message_generation
)

catkin_package(
	CATKIN_DEPENDS std_msgs message_runtime
)
add_message_files(
   FILES
   Person.msg
)
generate_messages(
   DEPENDENCIES
   std_msgs
)
```

# 发布者

## 节点初始化

+ 初始化ROS节点。
  ```cpp
  # argc/argv 为命令行输入参数, person_publisher 为节点名称，必须唯一
  ros::init(argc, argv, "person_publisher");  
  ```

+ 创建节点句柄，方便对节点资源的使用和管理。
```cpp
ros::NodeHandle n;
```
+ 创建和注册一个Publisher。消息队列一般在网络卡断的时候会有用，一般来说10适配 1-20Hz 的发布速率，过高 / 过低发布速率需调整（比如 100Hz 发布可设为 50，1Hz 发布设为 1）；
```cpp
// 创建Publisher, 话题名为/person_info, 消息类型learning_topic::Person, 10为消息队列大小
ros::Publisher person_info_pub = n.advertise<learning_topic::Person>("/person_info", 10);
```
+ 设置循环频率，单位Hz。一般对于需要循环发布的节点才需要设置Rate，在调用`sleep`时传入。
```cpp
ros::Rate loop_rate(1);
```

## 循环部分

+ 循环条件。在节点异常的情况下退出，异常包括：收到SIGINT信号、节点调用shutdown、NodeHandles句柄被销毁。
```cpp
while(ros::ok())
```
+ 发布消息，非阻塞式调用。消息会被放入一个内存队列（缓冲区），ROS 后台有专门的线程负责从队列中取出消息，发送给所有订阅者。
```cpp
person_info_pub.publish(person_msg);
```
+ 节点休眠
```cpp
loop_rate.sleep();
```


# 订阅者

## 回调函数

+ 回调函数的形参是消息指针。

```cpp
void personCallback(const learning_topic::Person::ConstPtr &msg)
{
	ROS_INFO("Subcribe Person Info: name:%s  age:%d  sex:%d", 
		 msg->name.c_str(), msg->age, msg->sex);
}
```

## 主函数

+ 创建订阅节点
```cpp
// 创建订阅，话题/person_info
ros::Subscriber person_info_sub = n.subscribe("/person_info", 10, personCallback);
```

+ 使用spin函数循环监听回调
```cpp
ros::spin();
```
