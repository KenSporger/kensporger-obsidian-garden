---
{"dg-publish":true,"permalink":"/机器人世界/ROS小车项目/01. ROS1架构学习/"}
---


# ROS版本对比

| ROS1 版本         | 适配 Ubuntu 版本   | 发布时间    | 官方支持周期    | 核心改进 / 特点                                           | 适用场景                                             |
| --------------- | -------------- | ------- | --------- | --------------------------------------------------- | ------------------------------------------------ |
| Kinetic Kame    | 16.04 (Xenial) | 2016.05 | 2016-2021 | 首次全面支持 Python3（部分工具仍依赖 Python2）；优化了导航栈              | 老旧项目 / 硬件驱动仅支持 Ubuntu16.04 的场景                   |
| Melodic Morenia | 18.04 (Bionic) | 2018.05 | 2018-2023 | 全面转向 Python3（兼容 Python2）；性能优化；修复大量 bug              | Ubuntu18.04 环境（经典稳定，很多开源项目基于此）                   |
| Noetic Ninjemys | 20.04 (Focal)  | 2020.05 | 2020-2025 | 纯 Python3（彻底放弃 Python2）；适配 Ubuntu20.04；最后一个 ROS1 版本 | 新项目 / 与 ROS2（如 Foxy/Humble）兼容（你的 Docker 场景优先选这个） |

| ROS2 版本              | 类型          | 支持周期      | 适配 Ubuntu | 适合场景               |
| -------------------- | ----------- | --------- | --------- | ------------------ |
| **Humble Hawksbill** | LTS（长期支持）   | 2022–2027 | 22.04 LTS | ✅ 生产、稳定开发、小车部署     |
| Jazzy Jalisco        | LTS（下一个长期版） | 2024–2029 | 24.04 LTS | ✅ 需搭配 Ubuntu 24.04 |
| Kilted               | 开发 / 测试版    | 短期        | 滚动更新      | ❌ 不适合稳定开发          |
| Rolling              | 滚动开发版       | 持续更新      | 最新 Ubuntu | ❌ 仅适合尝新，不适合小车      |

# 三层架构
![Pasted image 20260208191845.png](/img/user/%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%96%E7%95%8C/ROS%E5%B0%8F%E8%BD%A6%E9%A1%B9%E7%9B%AE/img/Pasted%20image%2020260208191845.png)
+ OS层：ROS基于Linux接口开发，需要运行于Linux系统上；
+ 中间层：在操作系统的基础上，ROS开发了一些为机器人提供的中间件，如通信机制、机器人基础算法库（坐标变化、数据类型定义、运动控制），有点类似于C++标准库；
+ 应用层：主要是用户自己编写的应用进程；

# 工程文件结构

## 功能包
{ #25df91}


![Pasted image 20260208192432.png](/img/user/%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%96%E7%95%8C/ROS%E5%B0%8F%E8%BD%A6%E9%A1%B9%E7%9B%AE/img/Pasted%20image%2020260208192432.png)
功能包里包括：
+ src：主要的工程源码（C++）
+ include：头文件
+ launch：启动文件
+ script：用于调试的python脚本
+ config：配置文件，用户可以填写一些设备参数
+ msg：自定义的消息类型
+ srv：自定义的服务类型
+ action：自定义的动作指令
+ package.xml：功能包的说明以及依赖列表

## ROS社区资源的组织形式
![Pasted image 20260208193047.png](/img/user/%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%96%E7%95%8C/ROS%E5%B0%8F%E8%BD%A6%E9%A1%B9%E7%9B%AE/img/Pasted%20image%2020260208193047.png)


# 通信机制

ROS的核心是**分布式通信机制**，所谓“分布式”就是指多进程节点之间的通信。

## 话题（topics）

在这种通信机制中，Master起到了“媒人”牵线搭桥的作用，Talker和Listener之间的数据传输Master并不参与，其次Talker和Listener没有先后启动顺序的要求。
![Pasted image 20260208194112.png](/img/user/%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%96%E7%95%8C/ROS%E5%B0%8F%E8%BD%A6%E9%A1%B9%E7%9B%AE/img/Pasted%20image%2020260208194112.png)
1. 发布者Talker通过1234端口使用RPC向Master注册节点；
2. 订阅者Listener也使用RPC向Master注册节点，Master在发布者加入后通过RPC将发布者的RPC地址（1234端口）给到Listener；
3. Listener通过1234端口使用RPC请求Talker建立TCP连接（也可以是UDP，消息类型可选）；
4. Talker通过RPC返回给Listener自己的TCP地址等连接信息；
5. Listener根据该地址使用TCP尝试与Talker建立网络连接；
6. 连接建立后，Talker通过TCP向Listener发送话题消息数据；
整个过程1-4步都是RPC通信，5-6是TCP通信，从第5步开始，可以关闭Master不影响后续的TCP通信。
### 为什么Master和节点使用RPC？

准确地说是XML-RPC协议。
+ 同步请求-响应式；
+ 适合低频度小数据的传输；
+ XML面向格式化流，不需要像TCP那样进行字节流的解析；
当然，ROS1可以改用更为现代的gRPC（HTTP/2 + Protobuf），通信更高效。ROS2用DDS内置的发现机制取代了中央Master，不再需要单独的RPC注册。

### 为什么节点间用TCP?

这个跟机场里模块进程的通信方式一样，通信传输的是字节流。

+ TCP适用于连续的、高频的、数据量较大、可靠性较高的数据通信；
+ 支持一对多;
+ 长连接；
ROS1里也可以选用UDP，适合远程控制这种可容忍丢失的场景，但大多数还是会用可靠性传输；ROS2支持共享内存，可以实现在同台机器间通信，避免拷贝；ROS2 采用 DDS 作为通信中间件，它提供了更丰富的通信模式和 QoS 策略，但底层仍然可能使用 TCP/UDP/共享内存等。

### 话题和DJI中的推送区别

DJI里的有些推送实际上是有问题的，比如遥控器断连、机场推送的可降落通知等等，都是没有接受者了，或者接受者还没想订阅呢，但是发送方一直在发，这造成了通信带宽的浪费。
而话题的好处是只要没有接收者了，TCP就断开，发布者就不再发送（当然接受Node一直在但就是不处理消息的浪费那就另外一回事了）。

第二，话题其实现实了类似CSDK中的Listen功能，只是CSDK中的Listen很多是靠定时去Get（服务）来实现的，这其实也是不太好的方式，双向浪费了一半带宽，不如让发布者定时在那推送。


## 服务（services）

![Pasted image 20260208202457.png](/img/user/%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%96%E7%95%8C/ROS%E5%B0%8F%E8%BD%A6%E9%A1%B9%E7%9B%AE/img/Pasted%20image%2020260208202457.png)
和话题通信的区别是在第二步中返回给Listener的不是RPC地址，而直接是TCP地址！这样一来原来的步骤3、4都省略了。
### 为什么服务通信Master能直接返回TCP？

主要的区别在于话题通信**采用了“延迟建立TCP”的模式**——即在Listener通过RPC请求建立TCP时Talker才初始化TCP，因此在注册节点的时候Master并不能提前知道Talker的TCP地址。
之所以这样，是因为现实情况机器上可能运行几十个话题，但大多数时间只有少数话题有订阅者。如果节点都在初始化时候就为话题建立了TCP，那系统的端口号很多就被占用并且闲置浪费了。
```

// 发布者
1. ros::init() 时创建XML-RPC服务器（固定端口）
2. 调用Master的registerPublisher()，注册自己的RPC地址
3. ⚠️ 此时还没有创建TCP服务器！

// 订阅者
1. 查询Master得到发布者的RPC地址
2. 调用发布者的requestTopic() RPC方法
3. 这时发布者才创建TCP服务器，返回端口号
4. 订阅者连接这个端口

```

而服务通信是在刚运行就初始化TCP Server的，这是因为服务端必须做到随时响应，因此要预先分配，这样以来还减少了RPC调用，延迟更小。

```python
def service_server():
    # 1. 启动时：先确定TCP端口（比如 45678）
    port = 45678  # 固定或配置的
    
    # 2. 启动TCP服务器
    start_tcp_server(port)
    
    # 3. 向Master注册：“我在45678端口提供服务X”
    #    这时服务器已经准备好接收连接了！
    
    # 客户端查询时，Master直接给45678
    # 客户端连45678，肯定能连上（如果服务还活着）
```

### 服务与话题的区别

| 方面           | 话题通信          | 服务通信          |
| ------------ | ------------- | ------------- |
| **同步性**      | 异步            | 同步            |
| **连接方向**     | 发布者作为TCP服务器   | 服务端作为TCP服务器   |
| **连接持久性**    | 长连接，保持到节点退出   | 短连接（通常），调用后关闭 |
| **Master作用** | 信息中介，不参与数据传输  | 信息中介，不参与数据传输  |
| **底层协议**     | ROSTCP/ROSUDP | ROSTCP/ROSUDP |
| **节点关系**     | 多对多           | 一对多（1个Server） |
| **适用场景**     | 数据传输          | 逻辑处理          |
注意服务是短连接，在响应成功后会关闭TCP连接。

## 动作（action）

在DJI的机场项目里，比如打开舱盖这种带一定过程和进度的动作，是开给APP两个接口——开关、进度接口。APP在开关返回成功后去监听进度接口判断最后是否真的关闭成功了，虽然能实现效果，但是APP层写起来就不是那么方便。
ROS中提供的Action和CSDK中的Action完全不一样，它支持返回进度等信息。
![Pasted image 20260208211120.png](/img/user/%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%96%E7%95%8C/ROS%E5%B0%8F%E8%BD%A6%E9%A1%B9%E7%9B%AE/img/Pasted%20image%2020260208211120.png)
+ goal：开始动作的目标；
+ cancel：取消动作
+ status：状态（PENDING、ABORTED...）
+ feedback：周期性任务监控数据回调（进度信息）
+ result：任务执行结果，只发送一次

## 参数（parameters）

![Pasted image 20260208204713.png](/img/user/%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%96%E7%95%8C/ROS%E5%B0%8F%E8%BD%A6%E9%A1%B9%E7%9B%AE/img/Pasted%20image%2020260208204713.png)
参数类似于全局变量，维护在Master中的参数表中，可被节点修改以及查询，但不具备更新后通知其他节点的功能。


## 重试逻辑（state的可靠性）是否支持？

在机场MissionCenter，经常遇到设备某个属性更新了要上报云端，这个情况下要在MissionCenter侧做一个定时重试的逻辑，这块在ROS中是否有现成的设计？
ROS2有QOS逻辑和持久化逻辑，但是ROS1得自己实现。